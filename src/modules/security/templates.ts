/**
 * Security Module Templates
 *
 * Handlebars templates for generating security-related code.
 */

import type { Template } from "../../core/types.js";

// ============================================================================
// SECURITY TEMPLATES
// ============================================================================

export const SECURITY_TEMPLATES: Template[] = [
  {
    id: "encryption_service",
    name: "Encryption Service",
    description: "AES-256-GCM encryption service with key derivation",
    type: "file",
    source: `// Encryption Service
// Generated by Offline Flutter PWA Builder

import 'dart:convert';
import 'dart:typed_data';
import 'package:encrypt/encrypt.dart' as encrypt;
import 'package:crypto/crypto.dart';
import 'package:pointycastle/export.dart';

/// Encryption service using {{algorithm}}
class EncryptionService {
  static const String _algorithm = '{{algorithm}}';
  static const int _iterations = {{iterations}};
  static const int _saltLength = {{saltLength}};
  static const int _keyLength = {{keyLength}};

  /// Encrypt data with password
  Future<String> encryptWithPassword(String data, String password) async {
    final salt = _generateSalt();
    final key = await _deriveKey(password, salt);
    final iv = encrypt.IV.fromSecureRandom(16);

    final encrypter = encrypt.Encrypter(
      encrypt.AES(key, mode: encrypt.AESMode.gcm),
    );

    final encrypted = encrypter.encrypt(data, iv: iv);

    // Combine salt + iv + encrypted data
    final combined = Uint8List.fromList([
      ...salt,
      ...iv.bytes,
      ...encrypted.bytes,
    ]);

    return base64.encode(combined);
  }

  /// Decrypt data with password
  Future<String> decryptWithPassword(String encryptedData, String password) async {
    final combined = base64.decode(encryptedData);

    // Extract salt, iv, and encrypted data
    final salt = combined.sublist(0, _saltLength);
    final iv = encrypt.IV(combined.sublist(_saltLength, _saltLength + 16));
    final cipherText = combined.sublist(_saltLength + 16);

    final key = await _deriveKey(password, salt);

    final encrypter = encrypt.Encrypter(
      encrypt.AES(key, mode: encrypt.AESMode.gcm),
    );

    return encrypter.decrypt(
      encrypt.Encrypted(cipherText),
      iv: iv,
    );
  }

  /// Generate cryptographically secure salt
  Uint8List _generateSalt() {
    final random = FortunaRandom();
    random.seed(KeyParameter(
      Uint8List.fromList(List.generate(32, (_) => DateTime.now().microsecondsSinceEpoch % 256)),
    ));
    return random.nextBytes(_saltLength);
  }

  /// Derive key from password using {{keyDerivation}}
  Future<encrypt.Key> _deriveKey(String password, Uint8List salt) async {
    final derivator = PBKDF2KeyDerivator(HMac(SHA256Digest(), 64))
      ..init(Pbkdf2Parameters(salt, _iterations, _keyLength));

    final key = derivator.process(Uint8List.fromList(utf8.encode(password)));
    return encrypt.Key(key);
  }

  /// Hash data with SHA-256
  String hashSha256(String data) {
    return sha256.convert(utf8.encode(data)).toString();
  }
}
`,
    output: {
      path: "lib/core/security",
      filename: "encryption_service",
      extension: ".dart",
    },
  },

  {
    id: "key_manager",
    name: "Key Manager",
    description: "Secure key management service",
    type: "file",
    source: `// Key Manager
// Generated by Offline Flutter PWA Builder

import 'dart:typed_data';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:pointycastle/export.dart';

/// Manages encryption keys securely
class KeyManager {
  static const String _masterKeyId = 'master_encryption_key';
  static const String _saltKeyId = 'master_key_salt';

  final FlutterSecureStorage _storage;

  KeyManager({FlutterSecureStorage? storage})
      : _storage = storage ?? const FlutterSecureStorage(
          aOptions: AndroidOptions(
            encryptedSharedPreferences: {{encryptedSharedPreferences}},
          ),
          iOptions: IOSOptions(
            accessibility: KeychainAccessibility.first_unlock_this_device,
          ),
        );

  /// Get or generate master key
  Future<Uint8List> getMasterKey() async {
    final existingKey = await _storage.read(key: _masterKeyId);

    if (existingKey != null) {
      return Uint8List.fromList(existingKey.codeUnits);
    }

    // Generate new master key
    final newKey = _generateSecureKey({{keyLength}});
    await _storage.write(
      key: _masterKeyId,
      value: String.fromCharCodes(newKey),
    );

    return newKey;
  }

  /// Generate a secure random key
  Uint8List _generateSecureKey(int length) {
    final random = FortunaRandom();
    random.seed(KeyParameter(
      Uint8List.fromList(
        List.generate(32, (_) => DateTime.now().microsecondsSinceEpoch % 256),
      ),
    ));
    return random.nextBytes(length);
  }

  /// Clear all keys (use with caution!)
  Future<void> clearAllKeys() async {
    await _storage.delete(key: _masterKeyId);
    await _storage.delete(key: _saltKeyId);
  }

  /// Check if keys exist
  Future<bool> hasKeys() async {
    return await _storage.containsKey(key: _masterKeyId);
  }
}
`,
    output: {
      path: "lib/core/security",
      filename: "key_manager",
      extension: ".dart",
    },
  },

  {
    id: "input_validator",
    name: "Input Validator",
    description: "Input validation with SQL injection and XSS protection",
    type: "file",
    source: `// Input Validator
// Generated by Offline Flutter PWA Builder

/// Input validator with SQL injection and XSS protection
class InputValidator {
  static const bool _preventSqlInjection = {{preventSqlInjection}};
  static const bool _xssProtection = {{xssProtection}};
  static const bool _htmlEncode = {{htmlEncode}};

  /// Sanitize input string
  static String sanitize(String input) {
    String result = input.trim();

    if (_preventSqlInjection) {
      result = _escapeSql(result);
    }

    if (_xssProtection) {
      result = _escapeXss(result);
    }

    if (_htmlEncode) {
      result = _encodeHtml(result);
    }

    return result;
  }

  /// Validate email format
  static bool isValidEmail(String email) {
    return RegExp(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')
        .hasMatch(email);
  }

  /// Validate phone number format
  static bool isValidPhone(String phone) {
    return RegExp(r'^\\+?[1-9]\\d{1,14}$').hasMatch(phone);
  }

  /// Validate URL format
  static bool isValidUrl(String url) {
    return Uri.tryParse(url)?.hasAbsolutePath ?? false;
  }

  /// Escape SQL special characters
  static String _escapeSql(String input) {
    return input
        .replaceAll("'", "''")
        .replaceAll("--", "")
        .replaceAll(";", "")
        .replaceAll("/*", "")
        .replaceAll("*/", "");
  }

  /// Escape XSS characters
  static String _escapeXss(String input) {
    return input
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#x27;')
        .replaceAll('/', '&#x2F;');
  }

  /// HTML encode special characters
  static String _encodeHtml(String input) {
    return input
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
  }

  /// Validate input length
  static bool isValidLength(String input, {int? min, int? max}) {
    if (min != null && input.length < min) return false;
    if (max != null && input.length > max) return false;
    return true;
  }
}
`,
    output: {
      path: "lib/core/security",
      filename: "input_validator",
      extension: ".dart",
    },
  },

  {
    id: "secure_storage_service",
    name: "Secure Storage Service",
    description: "Secure storage wrapper with encryption support",
    type: "file",
    source: `// Secure Storage Service
// Generated by Offline Flutter PWA Builder

import 'package:flutter_secure_storage/flutter_secure_storage.dart';

/// Secure storage service for sensitive data
class SecureStorageService {
  final FlutterSecureStorage _storage;

  SecureStorageService({FlutterSecureStorage? storage})
      : _storage = storage ?? const FlutterSecureStorage(
          aOptions: AndroidOptions(
            encryptedSharedPreferences: {{encryptedSharedPreferences}},
          ),
          iOptions: IOSOptions(
            accessibility: KeychainAccessibility.first_unlock_this_device,
          ),
        );

  /// Store a value securely
  Future<void> write(String key, String value) async {
    await _storage.write(key: key, value: value);
  }

  /// Read a secure value
  Future<String?> read(String key) async {
    return await _storage.read(key: key);
  }

  /// Delete a secure value
  Future<void> delete(String key) async {
    await _storage.delete(key: key);
  }

  /// Check if a key exists
  Future<bool> containsKey(String key) async {
    return await _storage.containsKey(key: key);
  }

  /// Get all keys
  Future<Map<String, String>> readAll() async {
    return await _storage.readAll();
  }

  /// Delete all stored values
  Future<void> deleteAll() async {
    await _storage.deleteAll();
  }
}
`,
    output: {
      path: "lib/core/security",
      filename: "secure_storage_service",
      extension: ".dart",
    },
  },

  {
    id: "audit_logger",
    name: "Audit Logger",
    description: "Security audit logging service",
    type: "file",
    source: `// Audit Logger
// Generated by Offline Flutter PWA Builder

import 'dart:convert';
import 'package:flutter/foundation.dart';

/// Audit event types
enum AuditEventType {
  authentication,
  authorization,
  data_access,
  data_modification,
  encryption,
  validation_failure,
  security_violation,
  configuration_change,
}

/// Audit log entry
class AuditLogEntry {
  final String id;
  final AuditEventType type;
  final String message;
  final DateTime timestamp;
  final String? userId;
  final Map<String, dynamic>? metadata;

  AuditLogEntry({
    required this.id,
    required this.type,
    required this.message,
    DateTime? timestamp,
    this.userId,
    this.metadata,
  }) : timestamp = timestamp ?? DateTime.now();

  Map<String, dynamic> toJson() => {
    'id': id,
    'type': type.name,
    'message': message,
    'timestamp': timestamp.toIso8601String(),
    'userId': userId,
    if (metadata != null) 'metadata': metadata,
  };
}

/// Audit logger for security events
class AuditLogger {
  static const String _logLevel = '{{logLevel}}';
  static const int _maxLogSize = {{maxLogSize}}; // KB

  final List<AuditLogEntry> _logs = [];
  int _logCounter = 0;

  /// Log an audit event
  void log(AuditEventType type, String message, {String? userId, Map<String, dynamic>? metadata}) {
    final entry = AuditLogEntry(
      id: 'AUDIT-\${++_logCounter}',
      type: type,
      message: message,
      userId: userId,
      metadata: metadata,
    );

    _logs.add(entry);
    _checkLogSize();

    if (kDebugMode) {
      print('[AUDIT] \${entry.type.name}: \${entry.message}');
    }
  }

  /// Get all logs
  List<AuditLogEntry> getLogs() => List.unmodifiable(_logs);

  /// Clear logs
  void clearLogs() {
    _logs.clear();
  }

  /// Export logs as JSON
  String exportLogsJson() {
    return jsonEncode(_logs.map((e) => e.toJson()).toList());
  }

  /// Check and rotate logs if necessary
  void _checkLogSize() {
    if (_logs.length > 10000) {
      _logs.removeRange(0, _logs.length - 5000);
    }
  }
}
`,
    output: {
      path: "lib/core/security",
      filename: "audit_logger",
      extension: ".dart",
    },
  },

  {
    id: "biometric_service",
    name: "Biometric Service",
    description: "Biometric authentication service",
    type: "file",
    source: `// Biometric Service
// Generated by Offline Flutter PWA Builder

import 'package:local_auth/local_auth.dart';

/// Biometric authentication service
class BiometricService {
  final LocalAuthentication _auth = LocalAuthentication();

  /// Check if biometrics are available
  Future<bool> isBiometricAvailable() async {
    try {
      final canAuthenticateWithBiometrics = await _auth.canCheckBiometrics;
      final canAuthenticate = canAuthenticateWithBiometrics || await _auth.isDeviceSupported();
      return canAuthenticate;
    } catch (e) {
      return false;
    }
  }

  /// Get available biometric types
  Future<List<BiometricType>> getAvailableBiometrics() async {
    try {
      return await _auth.getAvailableBiometrics();
    } catch (e) {
      return [];
    }
  }

  /// Authenticate with biometrics
  Future<bool> authenticate({
    String reason = 'Please authenticate to continue',
    bool biometricOnly = false,
  }) async {
    try {
      return await _auth.authenticate(
        localizedReason: reason,
        options: AuthenticationOptions(
          stickyAuth: true,
          biometricOnly: biometricOnly,
        ),
      );
    } catch (e) {
      return false;
    }
  }

  /// Cancel authentication
  Future<void> cancelAuthentication() async {
    await _auth.stopAuthentication();
  }
}
`,
    output: {
      path: "lib/core/security",
      filename: "biometric_service",
      extension: ".dart",
    },
  },

  {
    id: "security_barrel",
    name: "Security Barrel File",
    description: "Export file for all security services",
    type: "file",
    source: `// Security Services
// Generated by Offline Flutter PWA Builder

{{#if encryption}}
export 'encryption_service.dart';
export 'key_manager.dart';
{{/if}}
export 'input_validator.dart';
export 'secure_storage_service.dart';
{{#if audit}}
export 'audit_logger.dart';
{{/if}}
{{#if biometric}}
export 'biometric_service.dart';
{{/if}}
`,
    output: {
      path: "lib/core/security",
      filename: "security",
      extension: ".dart",
    },
  },
];

export default SECURITY_TEMPLATES;
