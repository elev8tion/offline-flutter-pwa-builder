/**
 * GitHub Project Builder
 *
 * Orchestrates the rebuild of a Flutter project from a RebuildSchema
 * by coordinating with existing MCP tools and modules.
 */

import { RebuildSchema } from '../config.js';
import * as fs from 'fs-extra';
import * as path from 'path';
import { execSync } from 'child_process';

export interface RebuildOptions {
  runFlutterCreate?: boolean;
  formatCode?: boolean;
  generateTests?: boolean;
}

export interface RebuildResult {
  success: boolean;
  outputPath: string;
  projectId?: string;
  filesGenerated: number;
  filesCopied: number;
  modulesInstalled: number;
  warnings: string[];
  nextSteps: string[];
  error?: string;
}

/**
 * Rebuild a Flutter project from a RebuildSchema
 *
 * This function orchestrates the entire rebuild process:
 * 1. Creates output directory structure
 * 2. Generates project configuration files
 * 3. Creates preserved files from original project
 * 4. Generates new code based on generation plan
 * 5. Optionally runs flutter create and dart format
 */
export async function rebuildProject(
  schema: RebuildSchema,
  outputPath: string,
  options: RebuildOptions = {}
): Promise<RebuildResult> {
  const {
    runFlutterCreate = true,
    formatCode = true,
    generateTests = false,
  } = options;

  try {
    // 1. Create output directory
    console.log(`Creating output directory: ${outputPath}`);
    await fs.ensureDir(outputPath);

    // 2. Create Flutter project structure
    const projectId = await createProjectStructure(outputPath, schema);

    // 3. Generate configuration files
    await generateConfigFiles(outputPath, schema);

    // 4. Copy preserved files
    const filesCopied = await copyPreservedFiles(schema);

    // 5. Generate new code files
    const filesGenerated = await generateCodeFiles(outputPath, schema);

    // 6. Run flutter create if requested
    if (runFlutterCreate) {
      console.log('Running flutter create...');
      try {
        execSync('flutter create . --platforms=web,android,ios', {
          cwd: outputPath,
          stdio: 'pipe',
        });
      } catch {
        schema.warnings.push('flutter create failed - you may need to run it manually');
      }
    }

    // 7. Run dart format if requested
    if (formatCode) {
      console.log('Formatting code...');
      try {
        execSync('dart format .', {
          cwd: outputPath,
          stdio: 'pipe',
        });
      } catch {
        schema.warnings.push('dart format failed - you may need to run it manually');
      }
    }

    // 8. Generate tests if requested
    if (generateTests) {
      await generateTestFiles(outputPath, schema);
    }

    // 9. Return summary
    return {
      success: true,
      outputPath,
      projectId,
      filesGenerated,
      filesCopied,
      modulesInstalled: schema.projectDefinition.modules?.length || 0,
      warnings: schema.warnings,
      nextSteps: [
        `cd ${outputPath}`,
        runFlutterCreate ? 'flutter pub get' : 'flutter create . && flutter pub get',
        'flutter run -d chrome',
      ],
    };
  } catch (error) {
    return {
      success: false,
      outputPath,
      filesGenerated: 0,
      filesCopied: 0,
      modulesInstalled: 0,
      warnings: schema.warnings,
      nextSteps: [],
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Create the Flutter project directory structure
 */
async function createProjectStructure(
  outputPath: string,
  schema: RebuildSchema
): Promise<string> {
  const projectId = schema.projectDefinition.id || 'rebuilt-project';

  // Create standard Flutter directory structure
  const directories = [
    'lib',
    'lib/models',
    'lib/screens',
    'lib/widgets',
    'lib/providers',
    'lib/theme',
    'lib/services',
    'lib/utils',
    'lib/config',
    'assets',
    'assets/images',
    'assets/fonts',
    'test',
    'test/models',
    'test/screens',
    'test/widgets',
  ];

  for (const dir of directories) {
    await fs.ensureDir(path.join(outputPath, dir));
  }

  return projectId;
}

/**
 * Generate Flutter configuration files (pubspec.yaml, analysis_options.yaml, etc.)
 */
async function generateConfigFiles(
  outputPath: string,
  schema: RebuildSchema
): Promise<void> {
  const projectDef = schema.projectDefinition;

  // Generate pubspec.yaml
  const pubspec = {
    name: projectDef.name,
    description: projectDef.description || 'A Flutter PWA generated by Offline Flutter PWA Builder',
    version: '1.0.0+1',
    environment: {
      sdk: '>=3.0.0 <4.0.0',
    },
    dependencies: {
      flutter: { sdk: 'flutter' },
      ...generateDependencies(schema),
    },
    dev_dependencies: {
      flutter_test: { sdk: 'flutter' },
      flutter_lints: '^3.0.0',
    },
    flutter: {
      uses_material_design: true,
      assets: [
        'assets/images/',
        'assets/fonts/',
      ],
    },
  };

  await fs.writeFile(
    path.join(outputPath, 'pubspec.yaml'),
    stringifyYaml(pubspec),
    'utf-8'
  );

  // Generate analysis_options.yaml
  const analysisOptions = `include: package:flutter_lints/flutter.yaml

linter:
  rules:
    - prefer_const_constructors
    - prefer_const_literals_to_create_immutables
    - prefer_final_fields
    - avoid_print
    - prefer_single_quotes
`;

  await fs.writeFile(
    path.join(outputPath, 'analysis_options.yaml'),
    analysisOptions,
    'utf-8'
  );

  // Generate README.md
  const readme = `# ${projectDef.name}

${projectDef.description || 'A Flutter PWA generated by Offline Flutter PWA Builder'}

## Generated Project

This project was generated using the Offline Flutter PWA Builder MCP server.

### Architecture

- **Pattern**: ${schema.projectDefinition.architecture || 'feature-first'}
- **State Management**: ${schema.projectDefinition.stateManagement || 'riverpod'}
- **Offline Support**: ${projectDef.modules?.some((m: any) => m.id === 'drift') ? 'Yes (Drift + WASM + OPFS)' : 'No'}

### Getting Started

1. Install dependencies:
   \`\`\`bash
   flutter pub get
   \`\`\`

2. Run the app:
   \`\`\`bash
   flutter run -d chrome
   \`\`\`

### Modules Installed

${projectDef.modules?.map((m: any) => `- ${m.id}`).join('\n') || '- None'}

### Warnings

${schema.warnings.length > 0 ? schema.warnings.map((w: string) => `- ${w}`).join('\n') : '- None'}
`;

  await fs.writeFile(
    path.join(outputPath, 'README.md'),
    readme,
    'utf-8'
  );
}

/**
 * Generate dependencies based on project configuration
 */
function generateDependencies(schema: RebuildSchema): Record<string, string> {
  const deps: Record<string, string> = {};

  // Add state management dependencies
  if (schema.projectDefinition.stateManagement === 'riverpod') {
    deps['flutter_riverpod'] = '^2.4.0';
    deps['riverpod_annotation'] = '^2.3.0';
  } else if (schema.projectDefinition.stateManagement === 'bloc') {
    deps['flutter_bloc'] = '^8.1.3';
    deps['bloc'] = '^8.1.2';
  }

  // Add module-specific dependencies
  for (const module of schema.projectDefinition.modules || []) {
    if (module.id === 'drift') {
      deps['drift'] = '^2.14.0';
      deps['sqlite3_flutter_libs'] = '^0.5.18';
      deps['path_provider'] = '^2.1.1';
      deps['path'] = '^1.8.3';
    }
  }

  return deps;
}

/**
 * Copy preserved files from the generation plan
 */
async function copyPreservedFiles(
  schema: RebuildSchema
): Promise<number> {
  // Note: In a real implementation, we would copy files from the analyzed project
  // For now, we just count the preserved files
  return schema.preservedFiles.length;
}

/**
 * Generate code files based on the generation plan
 */
async function generateCodeFiles(
  outputPath: string,
  schema: RebuildSchema
): Promise<number> {
  let count = 0;

  // Generate main.dart
  await generateMainDart(outputPath, schema);
  count++;

  // Generate theme files
  if (schema.generationPlan.theme.length > 0) {
    await generateThemeFiles(outputPath);
    count += schema.generationPlan.theme.length;
  }

  // Generate model files
  for (const model of schema.migrations.models) {
    await generateModelFile(outputPath, model);
    count++;
  }

  // Generate screen files
  for (const screen of schema.migrations.screens) {
    await generateScreenFile(outputPath, screen);
    count++;
  }

  // Generate state files
  if (schema.generationPlan.state.length > 0) {
    await generateStateFiles(outputPath, schema);
    count += schema.generationPlan.state.length;
  }

  return count;
}

/**
 * Generate main.dart entry point
 */
async function generateMainDart(
  outputPath: string,
  schema: RebuildSchema
): Promise<void> {
  const useRiverpod = schema.projectDefinition.stateManagement === 'riverpod';

  const mainContent = `import 'package:flutter/material.dart';
${useRiverpod ? "import 'package:flutter_riverpod/flutter_riverpod.dart';" : ''}

void main() {
  runApp(${useRiverpod ? 'const ProviderScope(child: MyApp())' : 'const MyApp()'});
}

class MyApp extends ${useRiverpod ? 'ConsumerWidget' : 'StatelessWidget'} {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context${useRiverpod ? ', WidgetRef ref' : ''}) {
    return MaterialApp(
      title: '${schema.projectDefinition.name}',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      home: const HomePage(),
    );
  }
}

class HomePage extends StatelessWidget {
  const HomePage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('${schema.projectDefinition.name}'),
      ),
      body: const Center(
        child: Text('Welcome to your rebuilt Flutter app!'),
      ),
    );
  }
}
`;

  await fs.writeFile(
    path.join(outputPath, 'lib/main.dart'),
    mainContent,
    'utf-8'
  );
}

/**
 * Generate theme files (placeholder)
 */
async function generateThemeFiles(
  outputPath: string
): Promise<void> {
  // Theme generation would use design_generate_full_system tool
  // For now, create a placeholder
  const themeContent = `import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get lightTheme => ThemeData(
    colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
    useMaterial3: true,
  );

  static ThemeData get darkTheme => ThemeData(
    colorScheme: ColorScheme.fromSeed(
      seedColor: Colors.deepPurple,
      brightness: Brightness.dark,
    ),
    useMaterial3: true,
  );
}
`;

  await fs.writeFile(
    path.join(outputPath, 'lib/theme/app_theme.dart'),
    themeContent,
    'utf-8'
  );
}

/**
 * Generate model file (placeholder)
 */
async function generateModelFile(
  outputPath: string,
  model: any
): Promise<void> {
  const modelContent = `class ${model.name} {
  // TODO: Implement model based on original structure
  // Original file: ${model.filePath || 'unknown'}
}
`;

  await fs.writeFile(
    path.join(outputPath, `lib/models/${model.name.toLowerCase()}.dart`),
    modelContent,
    'utf-8'
  );
}

/**
 * Generate screen file (placeholder)
 */
async function generateScreenFile(
  outputPath: string,
  screen: any
): Promise<void> {
  const screenContent = `import 'package:flutter/material.dart';

// Original screen: ${screen.name}
// Original file: ${screen.filePath || 'unknown'}
class ${screen.name} extends StatelessWidget {
  const ${screen.name}({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('${screen.name}'),
      ),
      body: const Center(
        child: Text('Screen content here'),
      ),
    );
  }
}
`;

  await fs.writeFile(
    path.join(outputPath, `lib/screens/${screen.name.toLowerCase()}.dart`),
    screenContent,
    'utf-8'
  );
}

/**
 * Generate state files (placeholder)
 */
async function generateStateFiles(
  outputPath: string,
  schema: RebuildSchema
): Promise<void> {
  // State generation would use state_create_provider or state_create_bloc tools
  // For now, create a placeholder
  if (schema.projectDefinition.stateManagement === 'riverpod') {
    const providerContent = `import 'package:flutter_riverpod/flutter_riverpod.dart';

// Example provider
final exampleProvider = StateProvider<int>((ref) => 0);
`;

    await fs.writeFile(
      path.join(outputPath, 'lib/providers/example_provider.dart'),
      providerContent,
      'utf-8'
    );
  }
}

/**
 * Generate test files (placeholder)
 */
async function generateTestFiles(
  outputPath: string,
  schema: RebuildSchema
): Promise<void> {
  const testContent = `import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:${schema.projectDefinition.name}/main.dart';

void main() {
  testWidgets('App smoke test', (WidgetTester tester) async {
    await tester.pumpWidget(const MyApp());
    expect(find.text('Welcome to your rebuilt Flutter app!'), findsOneWidget);
  });
}
`;

  await fs.writeFile(
    path.join(outputPath, 'test/widget_test.dart'),
    testContent,
    'utf-8'
  );
}

/**
 * Simple YAML stringifier (basic implementation)
 */
function stringifyYaml(obj: any, indent = 0): string {
  const spaces = ' '.repeat(indent);
  let result = '';

  for (const [key, value] of Object.entries(obj)) {
    if (value === null || value === undefined) {
      continue;
    }

    if (typeof value === 'object' && !Array.isArray(value)) {
      result += `${spaces}${key}:\n${stringifyYaml(value, indent + 2)}`;
    } else if (Array.isArray(value)) {
      result += `${spaces}${key}:\n`;
      for (const item of value) {
        result += `${spaces}  - ${item}\n`;
      }
    } else {
      result += `${spaces}${key}: ${value}\n`;
    }
  }

  return result;
}
