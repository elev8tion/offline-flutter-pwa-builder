/**
 * State Module Templates
 *
 * Handlebars templates for generating Riverpod providers, BLoC patterns,
 * and offline sync code.
 */

import type { Template } from "../../core/types.js";

// ============================================================================
// RIVERPOD TEMPLATES
// ============================================================================

const RIVERPOD_PROVIDER_TEMPLATE = `// {{name}} Provider
// Generated by Offline Flutter PWA Builder
// {{#if description}}// {{description}}{{/if}}

import 'package:flutter_riverpod/flutter_riverpod.dart';
{{#if dependencies}}
{{#each dependencies}}
import '{{this}}';
{{/each}}
{{/if}}

{{#if asyncState}}
/// Async provider for {{name}}
{{#if autoDispose}}final {{providerName}} = FutureProvider.autoDispose{{#if family}}.family{{/if}}<{{stateType}}{{#if family}}, {{familyParamType}}{{/if}}>((ref{{#if family}}, param{{/if}}) async {
{{else}}final {{providerName}} = FutureProvider{{#if family}}.family{{/if}}<{{stateType}}{{#if family}}, {{familyParamType}}{{/if}}>((ref{{#if family}}, param{{/if}}) async {
{{/if}}
  {{#if initialValue}}
  return {{initialValue}};
  {{else}}
  // TODO: Implement async logic
  throw UnimplementedError('{{name}} provider not implemented');
  {{/if}}
});
{{else}}
/// Provider for {{name}}
final {{providerName}} = Provider<{{stateType}}>((ref) {
  {{#if initialValue}}
  return {{initialValue}};
  {{else}}
  throw UnimplementedError('{{name}} provider not implemented');
  {{/if}}
});
{{/if}}
`;

const RIVERPOD_OFFLINE_PROVIDER_TEMPLATE = `// Offline Providers
// Generated by Offline Flutter PWA Builder

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:connectivity_plus/connectivity_plus.dart';

/// Connectivity provider
final connectivityProvider = StreamProvider<ConnectivityResult>((ref) {
  return Connectivity().onConnectivityChanged.map((results) => results.first);
});

/// Offline status provider
final isOfflineProvider = Provider<bool>((ref) {
  final connectivity = ref.watch(connectivityProvider);
  return connectivity.when(
    data: (result) => result == ConnectivityResult.none,
    loading: () => false,
    error: (_, __) => true,
  );
});

/// Sync queue state
class SyncQueueState {
  final List<SyncOperation> pending;
  final bool isSyncing;
  final String? lastError;

  const SyncQueueState({
    this.pending = const [],
    this.isSyncing = false,
    this.lastError,
  });

  SyncQueueState copyWith({
    List<SyncOperation>? pending,
    bool? isSyncing,
    String? lastError,
  }) {
    return SyncQueueState(
      pending: pending ?? this.pending,
      isSyncing: isSyncing ?? this.isSyncing,
      lastError: lastError,
    );
  }
}

/// Sync operation
class SyncOperation {
  final String id;
  final String type;
  final Map<String, dynamic> data;
  final DateTime createdAt;
  final int retryCount;

  SyncOperation({
    required this.id,
    required this.type,
    required this.data,
    required this.createdAt,
    this.retryCount = 0,
  });
}

/// Sync queue notifier
class SyncQueueNotifier extends StateNotifier<SyncQueueState> {
  SyncQueueNotifier() : super(const SyncQueueState());

  void addOperation(SyncOperation op) {
    state = state.copyWith(pending: [...state.pending, op]);
  }

  void removeOperation(String id) {
    state = state.copyWith(
      pending: state.pending.where((op) => op.id != id).toList(),
    );
  }

  void setSyncing(bool value) {
    state = state.copyWith(isSyncing: value);
  }

  void setError(String? error) {
    state = state.copyWith(lastError: error);
  }

  Future<void> syncAll() async {
    if (state.isSyncing || state.pending.isEmpty) return;

    setSyncing(true);
    setError(null);

    try {
      for (final op in state.pending) {
        // TODO: Implement actual sync logic
        await Future.delayed(const Duration(milliseconds: 100));
        removeOperation(op.id);
      }
    } catch (e) {
      setError(e.toString());
    } finally {
      setSyncing(false);
    }
  }
}

final syncQueueProvider = StateNotifierProvider<SyncQueueNotifier, SyncQueueState>((ref) {
  return SyncQueueNotifier();
});
`;

// ============================================================================
// BLOC TEMPLATES
// ============================================================================

const BLOC_EVENT_TEMPLATE = `// {{blocName}} Events
// Generated by Offline Flutter PWA Builder

part of '{{fileName}}.dart';

{{#if useEquatable}}
abstract class {{eventClass}} extends Equatable {
  const {{eventClass}}();

  @override
  List<Object?> get props => [];
}
{{else}}
abstract class {{eventClass}} {
  const {{eventClass}}();
}
{{/if}}

{{#each events}}
/// {{#if description}}{{description}}{{else}}{{name}} event{{/if}}
class {{name}} extends {{../eventClass}} {
  {{#if properties}}
  {{#each properties}}
  final {{type}} {{name}};
  {{/each}}

  const {{../name}}({
    {{#each properties}}
    {{#if required}}required {{/if}}this.{{name}},
    {{/each}}
  });

  {{#if ../useEquatable}}
  @override
  List<Object?> get props => [{{#each properties}}{{name}}{{#unless @last}}, {{/unless}}{{/each}}];
  {{/if}}
  {{else}}
  const {{name}}();
  {{/if}}
}

{{/each}}
`;

const BLOC_STATE_TEMPLATE = `// {{blocName}} States
// Generated by Offline Flutter PWA Builder

part of '{{fileName}}.dart';

{{#if useEquatable}}
abstract class {{stateClass}} extends Equatable {
  const {{stateClass}}();

  @override
  List<Object?> get props => [];
}
{{else}}
abstract class {{stateClass}} {
  const {{stateClass}}();
}
{{/if}}

{{#each states}}
/// {{#if description}}{{description}}{{else}}{{name}} state{{/if}}
class {{name}} extends {{../stateClass}} {
  {{#if properties}}
  {{#each properties}}
  final {{type}} {{name}};
  {{/each}}

  const {{../name}}({
    {{#each properties}}
    {{#if required}}required {{/if}}this.{{name}},
    {{/each}}
  });

  {{#if ../useEquatable}}
  @override
  List<Object?> get props => [{{#each properties}}{{name}}{{#unless @last}}, {{/unless}}{{/each}}];
  {{/if}}
  {{else}}
  const {{name}}();
  {{/if}}
}

{{/each}}
`;

const BLOC_MAIN_TEMPLATE = `// {{blocName}} BLoC
// Generated by Offline Flutter PWA Builder
{{#if description}}// {{description}}{{/if}}

import 'package:flutter_bloc/flutter_bloc.dart';
{{#if useEquatable}}
import 'package:equatable/equatable.dart';
{{/if}}

part '{{fileName}}_event.dart';
part '{{fileName}}_state.dart';

{{#if useCubit}}
/// {{blocName}} Cubit
class {{blocClass}} extends Cubit<{{stateClass}}> {
  {{blocClass}}() : super(const {{initialState}}());

  {{#each events}}
  /// Handle {{name}}
  void {{methodName}}({{#if properties}}{ {{#each properties}}{{#if required}}required {{/if}}{{type}} {{name}},{{/each}} }{{/if}}) {
    // TODO: Implement {{methodName}} logic
    // emit(NewState());
  }

  {{/each}}
}
{{else}}
/// {{blocName}} BLoC
class {{blocClass}} extends Bloc<{{eventClass}}, {{stateClass}}> {
  {{blocClass}}() : super(const {{initialState}}()) {
    {{#each events}}
    on<{{name}}>(_on{{name}});
    {{/each}}
  }

  {{#each events}}
  Future<void> _on{{name}}(
    {{name}} event,
    Emitter<{{../stateClass}}> emit,
  ) async {
    // TODO: Implement {{name}} handler
    // emit(NewState());
  }

  {{/each}}
}
{{/if}}
`;

const BLOC_OFFLINE_TEMPLATE = `// {{blocName}} Offline-Aware BLoC
// Generated by Offline Flutter PWA Builder

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'dart:async';

part '{{fileName}}_event.dart';
part '{{fileName}}_state.dart';

/// Base offline-aware BLoC
abstract class OfflineAwareBloc<E, S> extends Bloc<E, S> {
  StreamSubscription<List<ConnectivityResult>>? _connectivitySubscription;
  bool _isOnline = true;

  OfflineAwareBloc(super.initialState) {
    _connectivitySubscription = Connectivity()
        .onConnectivityChanged
        .listen(_onConnectivityChanged);
  }

  bool get isOnline => _isOnline;

  void _onConnectivityChanged(List<ConnectivityResult> results) {
    final wasOnline = _isOnline;
    _isOnline = results.isNotEmpty && results.first != ConnectivityResult.none;

    if (!wasOnline && _isOnline) {
      onReconnected();
    } else if (wasOnline && !_isOnline) {
      onDisconnected();
    }
  }

  /// Called when connection is restored
  void onReconnected() {
    // Override to handle reconnection (e.g., sync pending operations)
  }

  /// Called when connection is lost
  void onDisconnected() {
    // Override to handle disconnection
  }

  @override
  Future<void> close() {
    _connectivitySubscription?.cancel();
    return super.close();
  }
}

/// {{blocName}} BLoC with offline support
class {{blocClass}} extends OfflineAwareBloc<{{eventClass}}, {{stateClass}}> {
  final List<Map<String, dynamic>> _pendingOperations = [];

  {{blocClass}}() : super(const {{initialState}}()) {
    {{#each events}}
    on<{{name}}>(_on{{name}});
    {{/each}}
  }

  List<Map<String, dynamic>> get pendingOperations => List.unmodifiable(_pendingOperations);

  void queueOperation(String type, Map<String, dynamic> data) {
    _pendingOperations.add({
      'type': type,
      'data': data,
      'timestamp': DateTime.now().toIso8601String(),
    });
  }

  @override
  void onReconnected() {
    super.onReconnected();
    _syncPendingOperations();
  }

  Future<void> _syncPendingOperations() async {
    if (_pendingOperations.isEmpty) return;

    final operations = List<Map<String, dynamic>>.from(_pendingOperations);
    _pendingOperations.clear();

    for (final op in operations) {
      try {
        // TODO: Implement actual sync logic based on operation type
        await Future.delayed(const Duration(milliseconds: 100));
      } catch (e) {
        // Re-queue failed operations
        _pendingOperations.add(op);
      }
    }
  }

  {{#each events}}
  Future<void> _on{{name}}(
    {{name}} event,
    Emitter<{{../stateClass}}> emit,
  ) async {
    if (!isOnline) {
      // Queue for later sync
      queueOperation('{{name}}', {});
    }
    // TODO: Implement {{name}} handler
  }

  {{/each}}
}
`;

// ============================================================================
// FEATURE TEMPLATES
// ============================================================================

const FEATURE_REPOSITORY_TEMPLATE = `// {{featureName}} Repository
// Generated by Offline Flutter PWA Builder

{{#if useRiverpod}}
import 'package:flutter_riverpod/flutter_riverpod.dart';
{{/if}}

/// {{featureName}} Repository Interface
abstract class {{repositoryClassName}}Repository {
  {{#each operations}}
  {{#switch this}}
  {{#case "create"}}
  Future<{{../modelName}}> create({{../modelName}} item);
  {{/case}}
  {{#case "read"}}
  Future<{{../modelName}}?> getById(String id);
  {{/case}}
  {{#case "update"}}
  Future<{{../modelName}}> update({{../modelName}} item);
  {{/case}}
  {{#case "delete"}}
  Future<void> delete(String id);
  {{/case}}
  {{#case "list"}}
  Future<List<{{../modelName}}>> getAll();
  {{/case}}
  {{/switch}}
  {{/each}}
}

/// {{featureName}} Repository Implementation
class {{repositoryClassName}}RepositoryImpl implements {{repositoryClassName}}Repository {
  // TODO: Inject data source (local DB, API client)

  {{#each operations}}
  {{#switch this}}
  {{#case "create"}}
  @override
  Future<{{../modelName}}> create({{../modelName}} item) async {
    // TODO: Implement create
    throw UnimplementedError();
  }
  {{/case}}
  {{#case "read"}}
  @override
  Future<{{../modelName}}?> getById(String id) async {
    // TODO: Implement read
    throw UnimplementedError();
  }
  {{/case}}
  {{#case "update"}}
  @override
  Future<{{../modelName}}> update({{../modelName}} item) async {
    // TODO: Implement update
    throw UnimplementedError();
  }
  {{/case}}
  {{#case "delete"}}
  @override
  Future<void> delete(String id) async {
    // TODO: Implement delete
    throw UnimplementedError();
  }
  {{/case}}
  {{#case "list"}}
  @override
  Future<List<{{../modelName}}>> getAll() async {
    // TODO: Implement list
    throw UnimplementedError();
  }
  {{/case}}
  {{/switch}}

  {{/each}}
}

{{#if useRiverpod}}
/// Repository provider
final {{providerName}}RepositoryProvider = Provider<{{repositoryClassName}}Repository>((ref) {
  return {{repositoryClassName}}RepositoryImpl();
});
{{/if}}
`;

const FEATURE_MODEL_TEMPLATE = `// {{featureName}} Model
// Generated by Offline Flutter PWA Builder

{{#if useEquatable}}
import 'package:equatable/equatable.dart';
{{/if}}
{{#if useJsonSerializable}}
import 'package:json_annotation/json_annotation.dart';

part '{{fileName}}.g.dart';
{{/if}}

{{#if useJsonSerializable}}
@JsonSerializable()
{{/if}}
{{#if useEquatable}}
class {{modelClassName}} extends Equatable {
{{else}}
class {{modelClassName}} {
{{/if}}
  final String id;
  final DateTime createdAt;
  final DateTime updatedAt;
  // TODO: Add model properties

  const {{modelClassName}}({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
  });

  {{#if useJsonSerializable}}
  factory {{modelClassName}}.fromJson(Map<String, dynamic> json) => _\${{modelClassName}}FromJson(json);

  Map<String, dynamic> toJson() => _\${{modelClassName}}ToJson(this);
  {{/if}}

  {{modelClassName}} copyWith({
    String? id,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return {{modelClassName}}(
      id: id ?? this.id,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  {{#if useEquatable}}
  @override
  List<Object?> get props => [id, createdAt, updatedAt];
  {{/if}}
}
`;

// ============================================================================
// TEMPLATE DEFINITIONS
// ============================================================================

export const STATE_TEMPLATES: Template[] = [
  {
    id: "state-riverpod-provider",
    name: "Riverpod Provider",
    description: "Generate a Riverpod provider with various types",
    type: "file",
    source: RIVERPOD_PROVIDER_TEMPLATE,
    output: {
      path: "lib/providers",
      filename: "{{snakeName}}_provider",
      extension: "dart",
    },
  },
  {
    id: "state-riverpod-offline",
    name: "Riverpod Offline Provider",
    description: "Generate offline-aware Riverpod providers with sync queue",
    type: "file",
    source: RIVERPOD_OFFLINE_PROVIDER_TEMPLATE,
    output: {
      path: "lib/core/offline",
      filename: "offline_providers",
      extension: "dart",
    },
  },
  {
    id: "state-bloc-event",
    name: "BLoC Events",
    description: "Generate BLoC event classes",
    type: "file",
    source: BLOC_EVENT_TEMPLATE,
    output: {
      path: "lib/blocs",
      filename: "{{fileName}}_event",
      extension: "dart",
    },
  },
  {
    id: "state-bloc-state",
    name: "BLoC States",
    description: "Generate BLoC state classes",
    type: "file",
    source: BLOC_STATE_TEMPLATE,
    output: {
      path: "lib/blocs",
      filename: "{{fileName}}_state",
      extension: "dart",
    },
  },
  {
    id: "state-bloc-main",
    name: "BLoC Main",
    description: "Generate main BLoC/Cubit class",
    type: "file",
    source: BLOC_MAIN_TEMPLATE,
    output: {
      path: "lib/blocs",
      filename: "{{fileName}}",
      extension: "dart",
    },
  },
  {
    id: "state-bloc-offline",
    name: "BLoC Offline",
    description: "Generate offline-aware BLoC with sync queue",
    type: "file",
    source: BLOC_OFFLINE_TEMPLATE,
    output: {
      path: "lib/blocs",
      filename: "{{fileName}}",
      extension: "dart",
    },
  },
  {
    id: "state-feature-repository",
    name: "Feature Repository",
    description: "Generate repository pattern for a feature",
    type: "file",
    source: FEATURE_REPOSITORY_TEMPLATE,
    output: {
      path: "lib/features/{{snakeName}}/data",
      filename: "{{snakeName}}_repository",
      extension: "dart",
    },
  },
  {
    id: "state-feature-model",
    name: "Feature Model",
    description: "Generate model class for a feature",
    type: "file",
    source: FEATURE_MODEL_TEMPLATE,
    output: {
      path: "lib/features/{{snakeName}}/domain",
      filename: "{{snakeName}}",
      extension: "dart",
    },
  },
];

export default STATE_TEMPLATES;
