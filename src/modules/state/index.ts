/**
 * State Module
 *
 * Provides state management capabilities for Flutter applications.
 * Supports Riverpod and BLoC patterns with offline sync.
 *
 * Features:
 * - Riverpod provider generation (all provider types)
 * - BLoC/Cubit pattern generation
 * - Offline sync with queue persistence
 * - Feature generation (model + repository + state + UI)
 * - Code generation integration (Freezed, JSON serializable)
 */

import type { Module } from "../../core/types.js";
import { StateModuleConfig, DEFAULT_STATE_CONFIG, StateModuleConfigSchema } from "./config.js";
import { stateHooks } from "./hooks.js";
import { STATE_TOOLS, handleStateTool, type StateToolContext } from "./tools.js";
import { STATE_TEMPLATES } from "./templates.js";

// Re-export types and utilities
export * from "./config.js";
export { stateHooks, handleStateTool, STATE_TOOLS, STATE_TEMPLATES };
export type { StateToolContext };

// ============================================================================
// MODULE DEFINITION
// ============================================================================

export const STATE_MODULE: Module = {
  id: "state",
  name: "State Management",
  version: "1.0.0",
  description: "State management with Riverpod or BLoC patterns, including offline sync support",
  compatibleTargets: ["web", "android", "ios", "windows", "macos", "linux"],
  dependencies: [],
  conflicts: [],
  configSchema: StateModuleConfigSchema as unknown as Record<string, unknown>,
  defaultConfig: DEFAULT_STATE_CONFIG as unknown as Record<string, unknown>,
  templates: STATE_TEMPLATES,
  assets: [],
  hooks: stateHooks,
};

// ============================================================================
// MODULE REGISTRY HELPER
// ============================================================================

/**
 * Register the State module with a module system
 */
export function registerStateModule(moduleSystem: {
  register: (module: Module) => void;
}): void {
  moduleSystem.register(STATE_MODULE);
}

// ============================================================================
// PUBSPEC DEPENDENCIES
// ============================================================================

/**
 * Riverpod dependencies for pubspec
 */
export const RIVERPOD_DEPENDENCIES = {
  dependencies: {
    flutter_riverpod: "^2.4.9",
    riverpod_annotation: "^2.3.3",
    connectivity_plus: "^5.0.2",
  },
  devDependencies: {
    riverpod_generator: "^2.3.9",
    build_runner: "^2.4.8",
    riverpod_lint: "^2.3.7",
  },
};

/**
 * BLoC dependencies for pubspec
 */
export const BLOC_DEPENDENCIES = {
  dependencies: {
    flutter_bloc: "^8.1.3",
    bloc: "^8.1.2",
    equatable: "^2.0.5",
    connectivity_plus: "^5.0.2",
  },
  devDependencies: {
    bloc_test: "^9.1.5",
  },
};

/**
 * Provider dependencies for pubspec
 */
export const PROVIDER_DEPENDENCIES = {
  dependencies: {
    provider: "^6.1.1",
    connectivity_plus: "^5.0.2",
  },
  devDependencies: {},
};

/**
 * Get dependencies based on state management type
 */
export function getStateDependenciesForPubspec(type: StateModuleConfig["type"]): {
  dependencies: Record<string, string>;
  devDependencies: Record<string, string>;
} {
  switch (type) {
    case "riverpod":
      return RIVERPOD_DEPENDENCIES;
    case "bloc":
      return BLOC_DEPENDENCIES;
    case "provider":
      return PROVIDER_DEPENDENCIES;
    default:
      return { dependencies: {}, devDependencies: {} };
  }
}

// ============================================================================
// CODE GENERATION HELPERS
// ============================================================================

/**
 * Get build.yaml configuration for Riverpod code generation
 */
export function getRiverpodBuildYaml(): string {
  return `targets:
  \$default:
    builders:
      riverpod_generator:
        enabled: true
        options:
          # Automatically dispose providers when no longer needed
          provider_name_suffix: Provider
`;
}

/**
 * Get analysis_options.yaml configuration for Riverpod
 */
export function getRiverpodAnalysisOptions(): string {
  return `analyzer:
  plugins:
    - custom_lint

custom_lint:
  rules:
    - riverpod_final_provider
    - riverpod_missing_provider_scope
`;
}

// ============================================================================
// OFFLINE SYNC UTILITIES
// ============================================================================

/**
 * Generate offline sync service code
 */
export function generateOfflineSyncService(config: StateModuleConfig): string {
  return `// Offline Sync Service
// Generated by Offline Flutter PWA Builder

import 'dart:async';
import 'package:connectivity_plus/connectivity_plus.dart';

/// Offline sync service for managing operation queue
class OfflineSyncService {
  final List<SyncOperation> _queue = [];
  StreamSubscription<List<ConnectivityResult>>? _connectivitySubscription;
  bool _isOnline = true;
  bool _isSyncing = false;

  /// Maximum retry attempts
  final int maxRetries = ${config.offlineSync.retryAttempts};

  /// Delay between retries in milliseconds
  final int retryDelay = ${config.offlineSync.retryDelay};

  /// Initialize the sync service
  void initialize() {
    _connectivitySubscription = Connectivity()
        .onConnectivityChanged
        .listen(_onConnectivityChanged);
  }

  /// Dispose the sync service
  void dispose() {
    _connectivitySubscription?.cancel();
  }

  void _onConnectivityChanged(List<ConnectivityResult> results) {
    final wasOnline = _isOnline;
    _isOnline = results.isNotEmpty && results.first != ConnectivityResult.none;

    if (!wasOnline && _isOnline) {
      // Connection restored, sync pending operations
      syncAll();
    }
  }

  /// Check if currently online
  bool get isOnline => _isOnline;

  /// Check if currently syncing
  bool get isSyncing => _isSyncing;

  /// Get pending operations count
  int get pendingCount => _queue.length;

  /// Add an operation to the sync queue
  void enqueue(SyncOperation operation) {
    _queue.add(operation);
    ${config.offlineSync.strategy === "auto" ? "if (_isOnline) syncAll();" : ""}
  }

  /// Sync all pending operations
  Future<void> syncAll() async {
    if (_isSyncing || _queue.isEmpty) return;

    _isSyncing = true;

    try {
      final operations = List<SyncOperation>.from(_queue);

      for (final op in operations) {
        try {
          await _executeOperation(op);
          _queue.remove(op);
        } catch (e) {
          if (op.retryCount < maxRetries) {
            op.retryCount++;
            await Future.delayed(Duration(milliseconds: retryDelay));
          } else {
            // Max retries reached, operation will remain in queue
            print('Failed to sync operation: \${op.id}');
          }
        }
      }
    } finally {
      _isSyncing = false;
    }
  }

  Future<void> _executeOperation(SyncOperation op) async {
    // TODO: Implement actual sync logic based on operation type
    await Future.delayed(const Duration(milliseconds: 100));
  }
}

/// Sync operation
class SyncOperation {
  final String id;
  final String type;
  final Map<String, dynamic> data;
  final DateTime createdAt;
  int retryCount;

  SyncOperation({
    required this.id,
    required this.type,
    required this.data,
    DateTime? createdAt,
    this.retryCount = 0,
  }) : createdAt = createdAt ?? DateTime.now();
}
`;
}

// ============================================================================
// BEST PRACTICES
// ============================================================================

export const STATE_BEST_PRACTICES = [
  "Use autoDispose for providers that manage UI state",
  "Prefer StateNotifier over ChangeNotifier for complex state",
  "Use family providers for parameterized data",
  "Keep events and states immutable in BLoC",
  "Use Equatable for easy state comparison",
  "Implement proper error handling in async providers",
  "Test BLoCs with bloc_test package",
  "Use Freezed for immutable data classes",
  "Queue offline operations for sync when back online",
  "Persist sync queue to survive app restarts",
];

export default STATE_MODULE;
