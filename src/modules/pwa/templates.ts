/**
 * PWA Module Templates
 *
 * Handlebars templates for generating PWA files.
 */

import type { Template } from "../../core/types.js";

// ============================================================================
// MANIFEST TEMPLATE
// ============================================================================

const MANIFEST_TEMPLATE = `{
  "name": "{{config.name}}",
  "short_name": "{{config.shortName}}",
  {{#if config.description}}
  "description": "{{config.description}}",
  {{/if}}
  "theme_color": "{{config.themeColor}}",
  "background_color": "{{config.backgroundColor}}",
  "display": "{{config.display}}",
  "orientation": "{{config.orientation}}",
  "start_url": "{{config.startUrl}}",
  "scope": "{{config.scope}}",
  {{#if config.id}}
  "id": "{{config.id}}",
  {{/if}}
  "icons": [
    {{#each config.icons}}
    {
      "src": "{{this.src}}",
      "sizes": "{{this.sizes}}",
      "type": "{{this.type}}"{{#if this.purpose}},
      "purpose": "{{this.purpose}}"{{/if}}
    }{{#unless @last}},{{/unless}}
    {{/each}}
  ]{{#if config.categories.length}},
  "categories": {{{json config.categories}}}{{/if}}{{#if config.shortcuts.length}},
  "shortcuts": {{{json config.shortcuts}}}{{/if}}{{#if config.screenshots.length}},
  "screenshots": {{{json config.screenshots}}}{{/if}}{{#if config.relatedApplications.length}},
  "related_applications": {{{json config.relatedApplications}}},
  "prefer_related_applications": {{config.preferRelatedApplications}}{{/if}}
}`;

// ============================================================================
// SERVICE WORKER TEMPLATE
// ============================================================================

const SERVICE_WORKER_TEMPLATE = `// Flutter PWA Service Worker
// Generated by Offline Flutter PWA Builder

const CACHE_NAME = '{{project.name}}-cache-v1';
const OFFLINE_URL = '{{#if config.serviceWorker.offlineFallbackPage}}{{config.serviceWorker.offlineFallbackPage}}{{else}}/offline.html{{/if}}';

// Assets to precache
const PRECACHE_ASSETS = [
  '/',
  '/index.html',
  '/main.dart.js',
  '/manifest.json',
  '/flutter.js',
  '/favicon.png',
  {{#if config.serviceWorker.precacheAssets}}
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png',
  {{/if}}
];

// Runtime caching rules
const RUNTIME_CACHING_RULES = [
  {{#each config.serviceWorker.runtimeCaching}}
  {
    pattern: new RegExp('{{this.pattern}}'),
    strategy: '{{this.strategy}}',
    {{#if this.maxAgeSeconds}}maxAgeSeconds: {{this.maxAgeSeconds}},{{/if}}
    {{#if this.maxEntries}}maxEntries: {{this.maxEntries}},{{/if}}
  },
  {{/each}}
];

// Install event - precache assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log('[SW] Precaching assets');
      return cache.addAll(PRECACHE_ASSETS);
    })
  );
  {{#if config.serviceWorker.skipWaiting}}
  self.skipWaiting();
  {{/if}}
});

// Activate event - cleanup old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((name) => name !== CACHE_NAME)
          .map((name) => caches.delete(name))
      );
    })
  );
  {{#if config.serviceWorker.clientsClaim}}
  self.clients.claim();
  {{/if}}
});

// Fetch event - apply caching strategies
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') return;

  // Check runtime caching rules
  for (const rule of RUNTIME_CACHING_RULES) {
    if (rule.pattern.test(request.url)) {
      event.respondWith(handleCachingStrategy(request, rule));
      return;
    }
  }

  // Default: network first with cache fallback
  event.respondWith(networkFirst(request));
});

// Caching strategy handlers
async function handleCachingStrategy(request, rule) {
  switch (rule.strategy) {
    case 'cache-first':
      return cacheFirst(request, rule);
    case 'network-first':
      return networkFirst(request, rule);
    case 'stale-while-revalidate':
      return staleWhileRevalidate(request, rule);
    case 'network-only':
      return fetch(request);
    case 'cache-only':
      return caches.match(request);
    default:
      return networkFirst(request, rule);
  }
}

async function cacheFirst(request, rule = {}) {
  const cached = await caches.match(request);
  if (cached) {
    // Check if cache is expired
    if (rule.maxAgeSeconds) {
      const dateHeader = cached.headers.get('date');
      if (dateHeader) {
        const age = (Date.now() - new Date(dateHeader).getTime()) / 1000;
        if (age > rule.maxAgeSeconds) {
          return fetchAndCache(request);
        }
      }
    }
    return cached;
  }
  return fetchAndCache(request);
}

async function networkFirst(request, rule = {}) {
  try {
    const response = await fetch(request);
    if (response.ok) {
      const cache = await caches.open(CACHE_NAME);
      cache.put(request, response.clone());
    }
    return response;
  } catch (error) {
    const cached = await caches.match(request);
    if (cached) return cached;

    // Return offline page for navigation requests
    if (request.mode === 'navigate') {
      return caches.match(OFFLINE_URL);
    }
    throw error;
  }
}

async function staleWhileRevalidate(request, rule = {}) {
  const cache = await caches.open(CACHE_NAME);
  const cached = await cache.match(request);

  const fetchPromise = fetch(request).then((response) => {
    if (response.ok) {
      cache.put(request, response.clone());
    }
    return response;
  });

  return cached || fetchPromise;
}

async function fetchAndCache(request) {
  const response = await fetch(request);
  if (response.ok) {
    const cache = await caches.open(CACHE_NAME);
    cache.put(request, response.clone());
  }
  return response;
}

// Message handler for manual cache updates
self.addEventListener('message', (event) => {
  if (event.data === 'skipWaiting') {
    self.skipWaiting();
  }
  if (event.data === 'clearCache') {
    caches.delete(CACHE_NAME).then(() => {
      console.log('[SW] Cache cleared');
    });
  }
});
`;

// ============================================================================
// FLUTTER INSTALL PROMPT WIDGET TEMPLATE
// ============================================================================

const INSTALL_PROMPT_WIDGET_TEMPLATE = `import 'dart:html' as html;
import 'dart:js' as js;
import 'package:flutter/material.dart';

/// PWA Install Prompt Widget
///
/// Displays a customizable install prompt for Progressive Web Apps.
class InstallPromptWidget extends StatefulWidget {
  final String title;
  final String message;
  final String installButtonText;
  final String cancelButtonText;
  final VoidCallback? onInstall;
  final VoidCallback? onCancel;
  final Duration delay;
  final int showOnVisitCount;

  const InstallPromptWidget({
    Key? key,
    this.title = '{{config.installPrompt.promptTitle}}',
    this.message = '{{config.installPrompt.promptMessage}}',
    this.installButtonText = '{{config.installPrompt.promptInstallButton}}',
    this.cancelButtonText = '{{config.installPrompt.promptCancelButton}}',
    this.onInstall,
    this.onCancel,
    this.delay = const Duration(milliseconds: {{config.installPrompt.delay}}),
    this.showOnVisitCount = {{config.installPrompt.showOnVisit}},
  }) : super(key: key);

  @override
  State<InstallPromptWidget> createState() => _InstallPromptWidgetState();
}

class _InstallPromptWidgetState extends State<InstallPromptWidget> {
  bool _showPrompt = false;
  dynamic _deferredPrompt;

  @override
  void initState() {
    super.initState();
    _setupInstallPrompt();
  }

  void _setupInstallPrompt() {
    // Check if already installed
    if (_isStandalone()) return;

    // Check visit count
    final visitCount = _getVisitCount();
    if (visitCount < widget.showOnVisitCount) {
      _incrementVisitCount();
      return;
    }

    // Listen for beforeinstallprompt event
    html.window.addEventListener('beforeinstallprompt', (event) {
      event.preventDefault();
      _deferredPrompt = event;

      Future.delayed(widget.delay, () {
        if (mounted) {
          setState(() => _showPrompt = true);
        }
      });
    });
  }

  bool _isStandalone() {
    return html.window.matchMedia('(display-mode: standalone)').matches;
  }

  int _getVisitCount() {
    final stored = html.window.localStorage['pwa_visit_count'];
    return stored != null ? int.tryParse(stored) ?? 0 : 0;
  }

  void _incrementVisitCount() {
    final current = _getVisitCount();
    html.window.localStorage['pwa_visit_count'] = (current + 1).toString();
  }

  Future<void> _handleInstall() async {
    if (_deferredPrompt == null) return;

    // Show the install prompt
    js.context.callMethod('eval', ['''
      window.deferredPrompt.prompt();
      window.deferredPrompt.userChoice.then((choiceResult) => {
        window.deferredPrompt = null;
      });
    ''']);

    setState(() => _showPrompt = false);
    widget.onInstall?.call();
  }

  void _handleCancel() {
    setState(() => _showPrompt = false);
    html.window.localStorage['pwa_prompt_dismissed'] = 'true';
    widget.onCancel?.call();
  }

  @override
  Widget build(BuildContext context) {
    if (!_showPrompt) return const SizedBox.shrink();

    return Material(
      color: Colors.transparent,
      child: Container(
        margin: const EdgeInsets.all(16),
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          color: Theme.of(context).cardColor,
          borderRadius: BorderRadius.circular(16),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.1),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.download_rounded,
                  color: Theme.of(context).primaryColor,
                  size: 28,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    widget.title,
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: _handleCancel,
                  padding: EdgeInsets.zero,
                  constraints: const BoxConstraints(),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text(
              widget.message,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 20),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: _handleCancel,
                  child: Text(widget.cancelButtonText),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: _handleInstall,
                  child: Text(widget.installButtonText),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
`;

// ============================================================================
// FLUTTER OFFLINE INDICATOR WIDGET TEMPLATE
// ============================================================================

const OFFLINE_INDICATOR_WIDGET_TEMPLATE = `import 'dart:async';
import 'dart:html' as html;
import 'package:flutter/material.dart';

/// Offline Indicator Widget
///
/// Shows a banner when the app goes offline/online.
class OfflineIndicatorWidget extends StatefulWidget {
  final String offlineMessage;
  final String onlineMessage;
  final Duration showDuration;
  final OfflineIndicatorPosition position;
  final Widget? child;

  const OfflineIndicatorWidget({
    Key? key,
    this.offlineMessage = '{{config.offlineIndicator.message}}',
    this.onlineMessage = '{{config.offlineIndicator.onlineMessage}}',
    this.showDuration = const Duration(milliseconds: {{config.offlineIndicator.showDuration}}),
    this.position = OfflineIndicatorPosition.{{config.offlineIndicator.position}},
    this.child,
  }) : super(key: key);

  @override
  State<OfflineIndicatorWidget> createState() => _OfflineIndicatorWidgetState();
}

enum OfflineIndicatorPosition { top, bottom }

class _OfflineIndicatorWidgetState extends State<OfflineIndicatorWidget>
    with SingleTickerProviderStateMixin {
  bool _isOnline = true;
  bool _showBanner = false;
  bool _wasOffline = false;
  Timer? _hideTimer;
  late AnimationController _animationController;
  late Animation<Offset> _slideAnimation;

  @override
  void initState() {
    super.initState();
    _setupAnimations();
    _setupConnectivityListener();
    _checkInitialConnectivity();
  }

  void _setupAnimations() {
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );

    final beginOffset = widget.position == OfflineIndicatorPosition.top
        ? const Offset(0, -1)
        : const Offset(0, 1);

    _slideAnimation = Tween<Offset>(
      begin: beginOffset,
      end: Offset.zero,
    ).animate(CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOutCubic,
    ));
  }

  void _setupConnectivityListener() {
    html.window.addEventListener('online', (_) => _handleConnectivityChange(true));
    html.window.addEventListener('offline', (_) => _handleConnectivityChange(false));
  }

  void _checkInitialConnectivity() {
    final navigator = html.window.navigator;
    _isOnline = navigator.onLine ?? true;
    if (!_isOnline) {
      _showOfflineBanner();
    }
  }

  void _handleConnectivityChange(bool isOnline) {
    if (!mounted) return;

    setState(() {
      _isOnline = isOnline;
    });

    if (isOnline && _wasOffline) {
      _showOnlineBanner();
    } else if (!isOnline) {
      _showOfflineBanner();
    }
  }

  void _showOfflineBanner() {
    _wasOffline = true;
    _hideTimer?.cancel();
    setState(() => _showBanner = true);
    _animationController.forward();
  }

  void _showOnlineBanner() {
    _hideTimer?.cancel();
    setState(() => _showBanner = true);
    _animationController.forward();

    _hideTimer = Timer(widget.showDuration, () {
      if (mounted) {
        _animationController.reverse().then((_) {
          if (mounted) {
            setState(() {
              _showBanner = false;
              _wasOffline = false;
            });
          }
        });
      }
    });
  }

  @override
  void dispose() {
    _hideTimer?.cancel();
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final banner = _showBanner
        ? SlideTransition(
            position: _slideAnimation,
            child: Material(
              color: _isOnline ? Colors.green : Colors.red.shade700,
              child: SafeArea(
                top: widget.position == OfflineIndicatorPosition.top,
                bottom: widget.position == OfflineIndicatorPosition.bottom,
                child: Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        _isOnline ? Icons.wifi : Icons.wifi_off,
                        color: Colors.white,
                        size: 18,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        _isOnline ? widget.onlineMessage : widget.offlineMessage,
                        style: const TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          )
        : const SizedBox.shrink();

    if (widget.child == null) {
      return banner;
    }

    return Stack(
      children: [
        widget.child!,
        Positioned(
          top: widget.position == OfflineIndicatorPosition.top ? 0 : null,
          bottom: widget.position == OfflineIndicatorPosition.bottom ? 0 : null,
          left: 0,
          right: 0,
          child: banner,
        ),
      ],
    );
  }
}
`;

// ============================================================================
// FLUTTER PWA SERVICE (for JS interop)
// ============================================================================

const PWA_SERVICE_TEMPLATE = `import 'dart:async';
import 'dart:html' as html;
import 'dart:js' as js;

/// PWA Service
///
/// Provides PWA functionality including install prompts,
/// service worker management, and connectivity monitoring.
class PWAService {
  static final PWAService _instance = PWAService._internal();
  factory PWAService() => _instance;
  PWAService._internal();

  final _connectivityController = StreamController<bool>.broadcast();
  Stream<bool> get connectivityStream => _connectivityController.stream;

  bool _isInstalled = false;
  bool get isInstalled => _isInstalled;

  bool _canInstall = false;
  bool get canInstall => _canInstall;

  /// Initialize PWA service
  void initialize() {
    _checkIfInstalled();
    _setupConnectivityListeners();
    _setupInstallPromptListener();
    _registerServiceWorker();
  }

  void _checkIfInstalled() {
    _isInstalled = html.window.matchMedia('(display-mode: standalone)').matches;
  }

  void _setupConnectivityListeners() {
    html.window.addEventListener('online', (_) {
      _connectivityController.add(true);
    });
    html.window.addEventListener('offline', (_) {
      _connectivityController.add(false);
    });
  }

  void _setupInstallPromptListener() {
    html.window.addEventListener('beforeinstallprompt', (event) {
      event.preventDefault();
      _canInstall = true;
      // Store the event for later use
      js.context['deferredPrompt'] = event;
    });

    html.window.addEventListener('appinstalled', (_) {
      _isInstalled = true;
      _canInstall = false;
    });
  }

  Future<void> _registerServiceWorker() async {
    if (js.context.hasProperty('navigator') &&
        js.context['navigator'].hasProperty('serviceWorker')) {
      try {
        await js.context['navigator']['serviceWorker']
            .callMethod('register', ['/flutter_service_worker.js']);
        print('Service Worker registered');
      } catch (e) {
        print('Service Worker registration failed: \$e');
      }
    }
  }

  /// Check if app is online
  bool get isOnline => html.window.navigator.onLine ?? true;

  /// Prompt user to install the PWA
  Future<bool> promptInstall() async {
    if (!_canInstall) return false;

    try {
      final prompt = js.context['deferredPrompt'];
      if (prompt == null) return false;

      prompt.callMethod('prompt');

      final result = await js.context.callMethod('eval', ['''
        new Promise((resolve) => {
          window.deferredPrompt.userChoice.then((choiceResult) => {
            resolve(choiceResult.outcome === 'accepted');
          });
        })
      ''']);

      _canInstall = false;
      js.context['deferredPrompt'] = null;

      return result == true;
    } catch (e) {
      print('Install prompt failed: \$e');
      return false;
    }
  }

  /// Clear all cached data
  Future<void> clearCache() async {
    if (js.context.hasProperty('navigator') &&
        js.context['navigator'].hasProperty('serviceWorker')) {
      final registration = await js.context['navigator']['serviceWorker']
          .callMethod('getRegistration');
      if (registration != null) {
        registration.callMethod('postMessage', ['clearCache']);
      }
    }
  }

  /// Force update the service worker
  Future<void> updateServiceWorker() async {
    if (js.context.hasProperty('navigator') &&
        js.context['navigator'].hasProperty('serviceWorker')) {
      final registration = await js.context['navigator']['serviceWorker']
          .callMethod('getRegistration');
      if (registration != null) {
        await registration.callMethod('update');
      }
    }
  }

  void dispose() {
    _connectivityController.close();
  }
}
`;

// ============================================================================
// OFFLINE FALLBACK PAGE TEMPLATE
// ============================================================================

const OFFLINE_PAGE_TEMPLATE = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Offline - {{config.name}}</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background-color: {{config.backgroundColor}};
      color: #333;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .container {
      text-align: center;
      max-width: 400px;
    }
    .icon {
      width: 80px;
      height: 80px;
      margin-bottom: 24px;
    }
    .icon svg {
      width: 100%;
      height: 100%;
      fill: {{config.themeColor}};
    }
    h1 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #1a1a1a;
    }
    p {
      font-size: 16px;
      color: #666;
      line-height: 1.5;
      margin-bottom: 24px;
    }
    .retry-btn {
      display: inline-block;
      padding: 12px 32px;
      background-color: {{config.themeColor}};
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    .retry-btn:hover {
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="icon">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z" fill="none"/>
        <path d="M12 4c4.41 0 8 3.59 8 8s-3.59 8-8 8-8-3.59-8-8 3.59-8 8-8m0-2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z"/>
        <path d="M12 17c.55 0 1-.45 1-1v-4c0-.55-.45-1-1-1s-1 .45-1 1v4c0 .55.45 1 1 1zm0-10c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1z"/>
      </svg>
    </div>
    <h1>You're Offline</h1>
    <p>It looks like you've lost your internet connection. Please check your connection and try again.</p>
    <button class="retry-btn" onclick="window.location.reload()">
      Try Again
    </button>
  </div>
  <script>
    window.addEventListener('online', () => {
      window.location.reload();
    });
  </script>
</body>
</html>
`;

// ============================================================================
// INDEX.HTML MODIFICATION TEMPLATE
// ============================================================================

const INDEX_HTML_HEAD_TEMPLATE = `  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="{{config.themeColor}}">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="{{config.shortName}}">
  <meta name="application-name" content="{{config.shortName}}">
  <meta name="msapplication-TileColor" content="{{config.themeColor}}">
  <meta name="msapplication-config" content="/browserconfig.xml">

  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">

  <!-- Apple Touch Icons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
`;

// ============================================================================
// TEMPLATE DEFINITIONS
// ============================================================================

export const PWA_TEMPLATES: Template[] = [
  {
    id: "pwa-manifest",
    name: "PWA Manifest",
    description: "Web App Manifest file for PWA configuration",
    type: "file",
    source: MANIFEST_TEMPLATE,
    output: {
      path: "web",
      filename: "manifest",
      extension: "json",
    },
  },
  {
    id: "pwa-service-worker",
    name: "PWA Service Worker",
    description: "Service worker for offline caching and PWA functionality",
    type: "file",
    source: SERVICE_WORKER_TEMPLATE,
    output: {
      path: "web",
      filename: "flutter_service_worker",
      extension: "js",
    },
  },
  {
    id: "pwa-install-prompt",
    name: "Install Prompt Widget",
    description: "Flutter widget for PWA install prompt",
    type: "file",
    source: INSTALL_PROMPT_WIDGET_TEMPLATE,
    output: {
      path: "lib/core/pwa",
      filename: "install_prompt_widget",
      extension: "dart",
    },
  },
  {
    id: "pwa-offline-indicator",
    name: "Offline Indicator Widget",
    description: "Flutter widget for offline/online status indication",
    type: "file",
    source: OFFLINE_INDICATOR_WIDGET_TEMPLATE,
    output: {
      path: "lib/core/pwa",
      filename: "offline_indicator_widget",
      extension: "dart",
    },
  },
  {
    id: "pwa-service",
    name: "PWA Service",
    description: "Flutter service for PWA functionality",
    type: "file",
    source: PWA_SERVICE_TEMPLATE,
    output: {
      path: "lib/core/pwa",
      filename: "pwa_service",
      extension: "dart",
    },
  },
  {
    id: "pwa-offline-page",
    name: "Offline Fallback Page",
    description: "HTML page shown when offline and no cached content",
    type: "file",
    source: OFFLINE_PAGE_TEMPLATE,
    output: {
      path: "web",
      filename: "offline",
      extension: "html",
    },
  },
  {
    id: "pwa-index-head",
    name: "Index HTML Head Tags",
    description: "PWA-related meta tags for index.html",
    type: "snippet",
    source: INDEX_HTML_HEAD_TEMPLATE,
    output: {
      path: "web",
      filename: "index_head_snippet",
      extension: "html",
    },
  },
];

export default PWA_TEMPLATES;
